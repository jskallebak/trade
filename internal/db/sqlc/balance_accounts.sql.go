// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: balance_accounts.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBalanceRecord = `-- name: CreateBalanceRecord :one
INSERT INTO balance_history (binance_account_id, total_balance_usd, recorded_at)
VALUES ($1, $2, $3)
RETURNING id, binance_account_id, total_balance_usd, recorded_at
`

type CreateBalanceRecordParams struct {
	BinanceAccountID int32              `json:"binance_account_id"`
	TotalBalanceUsd  pgtype.Numeric     `json:"total_balance_usd"`
	RecordedAt       pgtype.Timestamptz `json:"recorded_at"`
}

func (q *Queries) CreateBalanceRecord(ctx context.Context, arg CreateBalanceRecordParams) (BalanceHistory, error) {
	row := q.db.QueryRow(ctx, createBalanceRecord, arg.BinanceAccountID, arg.TotalBalanceUsd, arg.RecordedAt)
	var i BalanceHistory
	err := row.Scan(
		&i.ID,
		&i.BinanceAccountID,
		&i.TotalBalanceUsd,
		&i.RecordedAt,
	)
	return i, err
}

const deleteOldBalanceRecords = `-- name: DeleteOldBalanceRecords :exec
DELETE FROM balance_history
WHERE recorded_at < $1
`

func (q *Queries) DeleteOldBalanceRecords(ctx context.Context, recordedAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteOldBalanceRecords, recordedAt)
	return err
}

const getAccountBalanceHistory = `-- name: GetAccountBalanceHistory :many
SELECT id, binance_account_id, total_balance_usd, recorded_at
FROM balance_history
WHERE binance_account_id = $1 
AND recorded_at >= $2
ORDER BY recorded_at DESC
LIMIT $3
`

type GetAccountBalanceHistoryParams struct {
	BinanceAccountID int32              `json:"binance_account_id"`
	RecordedAt       pgtype.Timestamptz `json:"recorded_at"`
	Limit            int32              `json:"limit"`
}

func (q *Queries) GetAccountBalanceHistory(ctx context.Context, arg GetAccountBalanceHistoryParams) ([]BalanceHistory, error) {
	rows, err := q.db.Query(ctx, getAccountBalanceHistory, arg.BinanceAccountID, arg.RecordedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BalanceHistory
	for rows.Next() {
		var i BalanceHistory
		if err := rows.Scan(
			&i.ID,
			&i.BinanceAccountID,
			&i.TotalBalanceUsd,
			&i.RecordedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestBalanceByAccount = `-- name: GetLatestBalanceByAccount :one
SELECT id, binance_account_id, total_balance_usd, recorded_at
FROM balance_history
WHERE binance_account_id = $1
ORDER BY recorded_at DESC
LIMIT 1
`

func (q *Queries) GetLatestBalanceByAccount(ctx context.Context, binanceAccountID int32) (BalanceHistory, error) {
	row := q.db.QueryRow(ctx, getLatestBalanceByAccount, binanceAccountID)
	var i BalanceHistory
	err := row.Scan(
		&i.ID,
		&i.BinanceAccountID,
		&i.TotalBalanceUsd,
		&i.RecordedAt,
	)
	return i, err
}

const getUserTotalBalance = `-- name: GetUserTotalBalance :one
SELECT COALESCE(SUM(bh.total_balance_usd), 0) as total_balance_usd
FROM (
    SELECT DISTINCT ON (binance_account_id) total_balance_usd
    FROM balance_history bh
    JOIN binance_accounts ba ON bh.binance_account_id = ba.id
    WHERE ba.user_id = $1 AND ba.is_active = true
    ORDER BY binance_account_id, recorded_at DESC
) latest_balances
`

func (q *Queries) GetUserTotalBalance(ctx context.Context, userID int32) (interface{}, error) {
	row := q.db.QueryRow(ctx, getUserTotalBalance, userID)
	var total_balance_usd interface{}
	err := row.Scan(&total_balance_usd)
	return total_balance_usd, err
}
