// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: binance_accounts.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBinanceAccount = `-- name: CreateBinanceAccount :one
INSERT INTO binance_accounts (user_id, name, api_key, api_secret, base_url)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, name, api_key, base_url, is_active, created_at, updated_at
`

type CreateBinanceAccountParams struct {
	UserID    int32       `json:"user_id"`
	Name      string      `json:"name"`
	ApiKey    string      `json:"api_key"`
	ApiSecret string      `json:"api_secret"`
	BaseUrl   pgtype.Text `json:"base_url"`
}

type CreateBinanceAccountRow struct {
	ID        int32              `json:"id"`
	UserID    int32              `json:"user_id"`
	Name      string             `json:"name"`
	ApiKey    string             `json:"api_key"`
	BaseUrl   pgtype.Text        `json:"base_url"`
	IsActive  pgtype.Bool        `json:"is_active"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateBinanceAccount(ctx context.Context, arg CreateBinanceAccountParams) (CreateBinanceAccountRow, error) {
	row := q.db.QueryRow(ctx, createBinanceAccount,
		arg.UserID,
		arg.Name,
		arg.ApiKey,
		arg.ApiSecret,
		arg.BaseUrl,
	)
	var i CreateBinanceAccountRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.ApiKey,
		&i.BaseUrl,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteBinanceAccount = `-- name: DeleteBinanceAccount :exec
UPDATE binance_accounts 
SET is_active = false, updated_at = NOW()
WHERE id = $1 AND user_id = $2
`

type DeleteBinanceAccountParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) DeleteBinanceAccount(ctx context.Context, arg DeleteBinanceAccountParams) error {
	_, err := q.db.Exec(ctx, deleteBinanceAccount, arg.ID, arg.UserID)
	return err
}

const getBinanceAccount = `-- name: GetBinanceAccount :one
SELECT id, user_id, name, api_key, api_secret, base_url, is_active
FROM binance_accounts
WHERE id = $1 AND user_id = $2 AND is_active = true
`

type GetBinanceAccountParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

type GetBinanceAccountRow struct {
	ID        int32       `json:"id"`
	UserID    int32       `json:"user_id"`
	Name      string      `json:"name"`
	ApiKey    string      `json:"api_key"`
	ApiSecret string      `json:"api_secret"`
	BaseUrl   pgtype.Text `json:"base_url"`
	IsActive  pgtype.Bool `json:"is_active"`
}

func (q *Queries) GetBinanceAccount(ctx context.Context, arg GetBinanceAccountParams) (GetBinanceAccountRow, error) {
	row := q.db.QueryRow(ctx, getBinanceAccount, arg.ID, arg.UserID)
	var i GetBinanceAccountRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.ApiKey,
		&i.ApiSecret,
		&i.BaseUrl,
		&i.IsActive,
	)
	return i, err
}

const getInactiveBinanceAccount = `-- name: GetInactiveBinanceAccount :one
SELECT id, user_id, name, api_key, api_secret, base_url, is_active, created_at, updated_at
FROM binance_accounts
WHERE user_id = $1 AND name = $2 AND is_active = false
`

type GetInactiveBinanceAccountParams struct {
	UserID int32  `json:"user_id"`
	Name   string `json:"name"`
}

type GetInactiveBinanceAccountRow struct {
	ID        int32              `json:"id"`
	UserID    int32              `json:"user_id"`
	Name      string             `json:"name"`
	ApiKey    string             `json:"api_key"`
	ApiSecret string             `json:"api_secret"`
	BaseUrl   pgtype.Text        `json:"base_url"`
	IsActive  pgtype.Bool        `json:"is_active"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetInactiveBinanceAccount(ctx context.Context, arg GetInactiveBinanceAccountParams) (GetInactiveBinanceAccountRow, error) {
	row := q.db.QueryRow(ctx, getInactiveBinanceAccount, arg.UserID, arg.Name)
	var i GetInactiveBinanceAccountRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.ApiKey,
		&i.ApiSecret,
		&i.BaseUrl,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserBinanceAccounts = `-- name: GetUserBinanceAccounts :many
SELECT id, user_id, name, api_key, api_secret, base_url, is_active, created_at, updated_at
FROM binance_accounts 
WHERE user_id = $1 AND is_active = true
`

type GetUserBinanceAccountsRow struct {
	ID        int32              `json:"id"`
	UserID    int32              `json:"user_id"`
	Name      string             `json:"name"`
	ApiKey    string             `json:"api_key"`
	ApiSecret string             `json:"api_secret"`
	BaseUrl   pgtype.Text        `json:"base_url"`
	IsActive  pgtype.Bool        `json:"is_active"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetUserBinanceAccounts(ctx context.Context, userID int32) ([]GetUserBinanceAccountsRow, error) {
	rows, err := q.db.Query(ctx, getUserBinanceAccounts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserBinanceAccountsRow
	for rows.Next() {
		var i GetUserBinanceAccountsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.ApiKey,
			&i.ApiSecret,
			&i.BaseUrl,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBinanceAccountsWithStatus = `-- name: GetUserBinanceAccountsWithStatus :many
SELECT 
    ba.id, ba.user_id, ba.name, ba.api_key, ba.api_secret, ba.base_url, ba.margin_enabled, ba.is_active, ba.created_at, ba.updated_at,
    CASE 
        WHEN b.id IS NOT NULL THEN true 
        ELSE false 
    END as account_active
FROM binance_accounts ba
LEFT JOIN bots b ON ba.id = b.binance_account_id
WHERE ba.user_id = $1 AND ba.is_active = true
`

type GetUserBinanceAccountsWithStatusRow struct {
	ID            int32              `json:"id"`
	UserID        int32              `json:"user_id"`
	Name          string             `json:"name"`
	ApiKey        string             `json:"api_key"`
	ApiSecret     string             `json:"api_secret"`
	BaseUrl       pgtype.Text        `json:"base_url"`
	MarginEnabled pgtype.Bool        `json:"margin_enabled"`
	IsActive      pgtype.Bool        `json:"is_active"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	AccountActive bool               `json:"account_active"`
}

func (q *Queries) GetUserBinanceAccountsWithStatus(ctx context.Context, userID int32) ([]GetUserBinanceAccountsWithStatusRow, error) {
	rows, err := q.db.Query(ctx, getUserBinanceAccountsWithStatus, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserBinanceAccountsWithStatusRow
	for rows.Next() {
		var i GetUserBinanceAccountsWithStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.ApiKey,
			&i.ApiSecret,
			&i.BaseUrl,
			&i.MarginEnabled,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccountActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reactivateBinanceAccount = `-- name: ReactivateBinanceAccount :one
UPDATE binance_accounts
SET 
    api_key = $3,
    api_secret = $4,
    base_url = $5,
    is_active = true,
    updated_at = NOW()
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, name, api_key, base_url, is_active, created_at, updated_at
`

type ReactivateBinanceAccountParams struct {
	ID        int32       `json:"id"`
	UserID    int32       `json:"user_id"`
	ApiKey    string      `json:"api_key"`
	ApiSecret string      `json:"api_secret"`
	BaseUrl   pgtype.Text `json:"base_url"`
}

type ReactivateBinanceAccountRow struct {
	ID        int32              `json:"id"`
	UserID    int32              `json:"user_id"`
	Name      string             `json:"name"`
	ApiKey    string             `json:"api_key"`
	BaseUrl   pgtype.Text        `json:"base_url"`
	IsActive  pgtype.Bool        `json:"is_active"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ReactivateBinanceAccount(ctx context.Context, arg ReactivateBinanceAccountParams) (ReactivateBinanceAccountRow, error) {
	row := q.db.QueryRow(ctx, reactivateBinanceAccount,
		arg.ID,
		arg.UserID,
		arg.ApiKey,
		arg.ApiSecret,
		arg.BaseUrl,
	)
	var i ReactivateBinanceAccountRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.ApiKey,
		&i.BaseUrl,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateBinanceAccount = `-- name: UpdateBinanceAccount :one
UPDATE binance_accounts
SET name = $3, api_key = $4, api_secret = $5, base_url = $6, updated_at = NOW()
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, name, api_key, base_url, is_active, created_at, updated_at
`

type UpdateBinanceAccountParams struct {
	ID        int32       `json:"id"`
	UserID    int32       `json:"user_id"`
	Name      string      `json:"name"`
	ApiKey    string      `json:"api_key"`
	ApiSecret string      `json:"api_secret"`
	BaseUrl   pgtype.Text `json:"base_url"`
}

type UpdateBinanceAccountRow struct {
	ID        int32              `json:"id"`
	UserID    int32              `json:"user_id"`
	Name      string             `json:"name"`
	ApiKey    string             `json:"api_key"`
	BaseUrl   pgtype.Text        `json:"base_url"`
	IsActive  pgtype.Bool        `json:"is_active"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateBinanceAccount(ctx context.Context, arg UpdateBinanceAccountParams) (UpdateBinanceAccountRow, error) {
	row := q.db.QueryRow(ctx, updateBinanceAccount,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.ApiKey,
		arg.ApiSecret,
		arg.BaseUrl,
	)
	var i UpdateBinanceAccountRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.ApiKey,
		&i.BaseUrl,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateBinanceAccountInfo = `-- name: UpdateBinanceAccountInfo :one
UPDATE binance_accounts
SET 
    name = $3,
    base_url = $4,
    updated_at = NOW()
WHERE id = $1 AND user_id = $2 AND is_active = true
RETURNING id, user_id, name, api_key, base_url, is_active, created_at, updated_at
`

type UpdateBinanceAccountInfoParams struct {
	ID      int32       `json:"id"`
	UserID  int32       `json:"user_id"`
	Name    string      `json:"name"`
	BaseUrl pgtype.Text `json:"base_url"`
}

type UpdateBinanceAccountInfoRow struct {
	ID        int32              `json:"id"`
	UserID    int32              `json:"user_id"`
	Name      string             `json:"name"`
	ApiKey    string             `json:"api_key"`
	BaseUrl   pgtype.Text        `json:"base_url"`
	IsActive  pgtype.Bool        `json:"is_active"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateBinanceAccountInfo(ctx context.Context, arg UpdateBinanceAccountInfoParams) (UpdateBinanceAccountInfoRow, error) {
	row := q.db.QueryRow(ctx, updateBinanceAccountInfo,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.BaseUrl,
	)
	var i UpdateBinanceAccountInfoRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.ApiKey,
		&i.BaseUrl,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
