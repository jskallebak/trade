// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: webhook_logs.sql

package db

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const createWebhookLog = `-- name: CreateWebhookLog :one
INSERT INTO webhook_logs (
    webhook_source, event_type, method, url_path, headers, query_params, 
    request_body, response_status, response_body, ip_address, user_agent, 
    processing_time_ms, error_message, is_successful
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) RETURNING id, webhook_source, event_type, created_at
`

type CreateWebhookLogParams struct {
	WebhookSource    string      `json:"webhook_source"`
	EventType        pgtype.Text `json:"event_type"`
	Method           string      `json:"method"`
	UrlPath          string      `json:"url_path"`
	Headers          []byte      `json:"headers"`
	QueryParams      []byte      `json:"query_params"`
	RequestBody      []byte      `json:"request_body"`
	ResponseStatus   pgtype.Int4 `json:"response_status"`
	ResponseBody     pgtype.Text `json:"response_body"`
	IpAddress        *netip.Addr `json:"ip_address"`
	UserAgent        pgtype.Text `json:"user_agent"`
	ProcessingTimeMs pgtype.Int4 `json:"processing_time_ms"`
	ErrorMessage     pgtype.Text `json:"error_message"`
	IsSuccessful     pgtype.Bool `json:"is_successful"`
}

type CreateWebhookLogRow struct {
	ID            int32              `json:"id"`
	WebhookSource string             `json:"webhook_source"`
	EventType     pgtype.Text        `json:"event_type"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateWebhookLog(ctx context.Context, arg CreateWebhookLogParams) (CreateWebhookLogRow, error) {
	row := q.db.QueryRow(ctx, createWebhookLog,
		arg.WebhookSource,
		arg.EventType,
		arg.Method,
		arg.UrlPath,
		arg.Headers,
		arg.QueryParams,
		arg.RequestBody,
		arg.ResponseStatus,
		arg.ResponseBody,
		arg.IpAddress,
		arg.UserAgent,
		arg.ProcessingTimeMs,
		arg.ErrorMessage,
		arg.IsSuccessful,
	)
	var i CreateWebhookLogRow
	err := row.Scan(
		&i.ID,
		&i.WebhookSource,
		&i.EventType,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOldWebhookLogs = `-- name: DeleteOldWebhookLogs :exec
DELETE FROM webhook_logs
WHERE created_at < $1
`

func (q *Queries) DeleteOldWebhookLogs(ctx context.Context, createdAt pgtype.Timestamptz) error {
	_, err := q.db.Exec(ctx, deleteOldWebhookLogs, createdAt)
	return err
}

const getFailedWebhookLogs = `-- name: GetFailedWebhookLogs :many
SELECT id, webhook_source, event_type, method, url_path, response_status,
       ip_address, processing_time_ms, error_message, is_successful, created_at
FROM webhook_logs
WHERE is_successful = false
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetFailedWebhookLogsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetFailedWebhookLogsRow struct {
	ID               int32              `json:"id"`
	WebhookSource    string             `json:"webhook_source"`
	EventType        pgtype.Text        `json:"event_type"`
	Method           string             `json:"method"`
	UrlPath          string             `json:"url_path"`
	ResponseStatus   pgtype.Int4        `json:"response_status"`
	IpAddress        *netip.Addr        `json:"ip_address"`
	ProcessingTimeMs pgtype.Int4        `json:"processing_time_ms"`
	ErrorMessage     pgtype.Text        `json:"error_message"`
	IsSuccessful     pgtype.Bool        `json:"is_successful"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetFailedWebhookLogs(ctx context.Context, arg GetFailedWebhookLogsParams) ([]GetFailedWebhookLogsRow, error) {
	rows, err := q.db.Query(ctx, getFailedWebhookLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFailedWebhookLogsRow
	for rows.Next() {
		var i GetFailedWebhookLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.WebhookSource,
			&i.EventType,
			&i.Method,
			&i.UrlPath,
			&i.ResponseStatus,
			&i.IpAddress,
			&i.ProcessingTimeMs,
			&i.ErrorMessage,
			&i.IsSuccessful,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebhookLog = `-- name: GetWebhookLog :one
SELECT id, webhook_source, event_type, method, url_path, headers, query_params,
       request_body, response_status, response_body, ip_address, user_agent,
       processing_time_ms, error_message, is_successful, created_at
FROM webhook_logs
WHERE id = $1
`

func (q *Queries) GetWebhookLog(ctx context.Context, id int32) (WebhookLog, error) {
	row := q.db.QueryRow(ctx, getWebhookLog, id)
	var i WebhookLog
	err := row.Scan(
		&i.ID,
		&i.WebhookSource,
		&i.EventType,
		&i.Method,
		&i.UrlPath,
		&i.Headers,
		&i.QueryParams,
		&i.RequestBody,
		&i.ResponseStatus,
		&i.ResponseBody,
		&i.IpAddress,
		&i.UserAgent,
		&i.ProcessingTimeMs,
		&i.ErrorMessage,
		&i.IsSuccessful,
		&i.CreatedAt,
	)
	return i, err
}

const getWebhookLogs = `-- name: GetWebhookLogs :many
SELECT id, webhook_source, event_type, method, url_path, response_status,
       ip_address, processing_time_ms, error_message, is_successful, created_at
FROM webhook_logs
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type GetWebhookLogsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetWebhookLogsRow struct {
	ID               int32              `json:"id"`
	WebhookSource    string             `json:"webhook_source"`
	EventType        pgtype.Text        `json:"event_type"`
	Method           string             `json:"method"`
	UrlPath          string             `json:"url_path"`
	ResponseStatus   pgtype.Int4        `json:"response_status"`
	IpAddress        *netip.Addr        `json:"ip_address"`
	ProcessingTimeMs pgtype.Int4        `json:"processing_time_ms"`
	ErrorMessage     pgtype.Text        `json:"error_message"`
	IsSuccessful     pgtype.Bool        `json:"is_successful"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetWebhookLogs(ctx context.Context, arg GetWebhookLogsParams) ([]GetWebhookLogsRow, error) {
	rows, err := q.db.Query(ctx, getWebhookLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWebhookLogsRow
	for rows.Next() {
		var i GetWebhookLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.WebhookSource,
			&i.EventType,
			&i.Method,
			&i.UrlPath,
			&i.ResponseStatus,
			&i.IpAddress,
			&i.ProcessingTimeMs,
			&i.ErrorMessage,
			&i.IsSuccessful,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebhookLogsByDateRange = `-- name: GetWebhookLogsByDateRange :many
SELECT id, webhook_source, event_type, method, url_path, response_status,
       ip_address, processing_time_ms, error_message, is_successful, created_at
FROM webhook_logs
WHERE created_at BETWEEN $1 AND $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type GetWebhookLogsByDateRangeParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
	Limit       int32              `json:"limit"`
	Offset      int32              `json:"offset"`
}

type GetWebhookLogsByDateRangeRow struct {
	ID               int32              `json:"id"`
	WebhookSource    string             `json:"webhook_source"`
	EventType        pgtype.Text        `json:"event_type"`
	Method           string             `json:"method"`
	UrlPath          string             `json:"url_path"`
	ResponseStatus   pgtype.Int4        `json:"response_status"`
	IpAddress        *netip.Addr        `json:"ip_address"`
	ProcessingTimeMs pgtype.Int4        `json:"processing_time_ms"`
	ErrorMessage     pgtype.Text        `json:"error_message"`
	IsSuccessful     pgtype.Bool        `json:"is_successful"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetWebhookLogsByDateRange(ctx context.Context, arg GetWebhookLogsByDateRangeParams) ([]GetWebhookLogsByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, getWebhookLogsByDateRange,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWebhookLogsByDateRangeRow
	for rows.Next() {
		var i GetWebhookLogsByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.WebhookSource,
			&i.EventType,
			&i.Method,
			&i.UrlPath,
			&i.ResponseStatus,
			&i.IpAddress,
			&i.ProcessingTimeMs,
			&i.ErrorMessage,
			&i.IsSuccessful,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebhookLogsBySource = `-- name: GetWebhookLogsBySource :many
SELECT id, webhook_source, event_type, method, url_path, response_status,
       ip_address, processing_time_ms, error_message, is_successful, created_at
FROM webhook_logs
WHERE webhook_source = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type GetWebhookLogsBySourceParams struct {
	WebhookSource string `json:"webhook_source"`
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
}

type GetWebhookLogsBySourceRow struct {
	ID               int32              `json:"id"`
	WebhookSource    string             `json:"webhook_source"`
	EventType        pgtype.Text        `json:"event_type"`
	Method           string             `json:"method"`
	UrlPath          string             `json:"url_path"`
	ResponseStatus   pgtype.Int4        `json:"response_status"`
	IpAddress        *netip.Addr        `json:"ip_address"`
	ProcessingTimeMs pgtype.Int4        `json:"processing_time_ms"`
	ErrorMessage     pgtype.Text        `json:"error_message"`
	IsSuccessful     pgtype.Bool        `json:"is_successful"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetWebhookLogsBySource(ctx context.Context, arg GetWebhookLogsBySourceParams) ([]GetWebhookLogsBySourceRow, error) {
	rows, err := q.db.Query(ctx, getWebhookLogsBySource, arg.WebhookSource, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWebhookLogsBySourceRow
	for rows.Next() {
		var i GetWebhookLogsBySourceRow
		if err := rows.Scan(
			&i.ID,
			&i.WebhookSource,
			&i.EventType,
			&i.Method,
			&i.UrlPath,
			&i.ResponseStatus,
			&i.IpAddress,
			&i.ProcessingTimeMs,
			&i.ErrorMessage,
			&i.IsSuccessful,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebhookStatsbySource = `-- name: GetWebhookStatsbySource :many
SELECT webhook_source,
       COUNT(*) as total_requests,
       COUNT(*) FILTER (WHERE is_successful = true) as successful_requests,
       COUNT(*) FILTER (WHERE is_successful = false) as failed_requests,
       AVG(processing_time_ms) as avg_processing_time_ms,
       MAX(created_at) as last_request_at
FROM webhook_logs
WHERE created_at >= $1
GROUP BY webhook_source
ORDER BY total_requests DESC
`

type GetWebhookStatsbySourceRow struct {
	WebhookSource       string      `json:"webhook_source"`
	TotalRequests       int64       `json:"total_requests"`
	SuccessfulRequests  int64       `json:"successful_requests"`
	FailedRequests      int64       `json:"failed_requests"`
	AvgProcessingTimeMs float64     `json:"avg_processing_time_ms"`
	LastRequestAt       interface{} `json:"last_request_at"`
}

func (q *Queries) GetWebhookStatsbySource(ctx context.Context, createdAt pgtype.Timestamptz) ([]GetWebhookStatsbySourceRow, error) {
	rows, err := q.db.Query(ctx, getWebhookStatsbySource, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWebhookStatsbySourceRow
	for rows.Next() {
		var i GetWebhookStatsbySourceRow
		if err := rows.Scan(
			&i.WebhookSource,
			&i.TotalRequests,
			&i.SuccessfulRequests,
			&i.FailedRequests,
			&i.AvgProcessingTimeMs,
			&i.LastRequestAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
